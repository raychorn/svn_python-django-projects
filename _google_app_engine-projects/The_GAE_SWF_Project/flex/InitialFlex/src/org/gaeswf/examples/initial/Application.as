/*	The GAE SWF Project: 	Knowledge and tools to help you build Flash and Flex apps on Google App Engine.		Copyright (c) 2008 Aral Balkan. All Rights Reserved.	Released under the open source MIT License. See LICENSE.txt for full license terms.	Application class	=================	Top-level form. In the future, some of the functionality here will be pulled up	to a new base class. */package org.gaeswf.examples.initial{	import flash.events.Event;	import flash.events.MouseEvent;		import mx.containers.TabNavigator;	import mx.controls.Button;	import mx.controls.Label;	import mx.controls.TextArea;	import mx.events.IndexChangedEvent;		import org.gaeswf.Service;	import org.gaeswf.flex.BaseApplication;		public class Application extends BaseApplication	{		// In MXML:		public var accessURLLabel:Label;		public var authStatusLabel:Label;		public var tabNav:TabNavigator;		public var loginButton:Button;		public var outputLabel:TextArea;				public var pyamfBug:Button;				// The two screens/states.		public var profile:ProfileScreen;		public var home:Home;													// URL mappings (in this simple example, they merely map		// to the indices of the main navigation tabs. In a more complicated		// example, you'd probably want to map them to states.)		private var urls:Array = 		[			{path: "/", auth: false},			{path: "/mousewheel", auth: false},			{path: "/profile", auth: true}		];										// Constructor		function Application()		{			// All the good stuff happens in init().		}				override protected function init(event:Event):void		{			super.init(event);						// Initialize the model.			Model.init();			// Stage properties.			stage.frameRate = 30;			stage.scaleMode="showAll";			stage.align="TL";			// Add listeners.			loginButton.addEventListener(MouseEvent.CLICK, loginButtonClickHandler);			tabNav.addEventListener(IndexChangedEvent.CHANGE, tabChangeHandler);					}								//		// Event handlers		//				// Service handlers (public)				public function user_getUrlsResponse(result:Object):void		{			outputLabel.text = "Login URL: " + Model.loginURL + "\nLogout URL: "+ Model.logoutURL;		}			public function user_loginResponse(event:Object):void		{			// Display auth status			if (Model.auth)			{				var user:Object = Model.user;								// User is logged in				authStatusLabel.text = (Model.profile.name == null) ? "Hello, stranger! Wanna fill out your profile?" : "Welcome back, " + Model.profile.name + "!";				loginButton.label = "Logout";								// Add the profile screen				// tabs.dataProvider.addItemAt({label:"Profile",data:1}, 1);				if (profile == null)				{					profile = new ProfileScreen();				}				if (!tabNav.contains(profile))				{					tabNav.addChild(profile);				}				// Log user details				for (var userItem:String in user)				{					outputLabel.text += (userItem + " = " + user[userItem] + "\n");				}			}			else			{				if (tabNav.contains(profile))				{					tabNav.removeChild(profile);				}								authStatusLabel.text = "Please login to continue.";				loginButton.label = "Login";			}				// Log the returned results			outputLabel.text += ("loginURL = " + Model.loginURL + "\n");			outputLabel.text += ("logoutURL =  " + Model.logoutURL + "\n");			outputLabel.text += ("auth = " + Model.auth + "\n");						// Handle SWFAddress mappings			urlChange();		}				public function user_loginFault(event:Object):void		{			trace("user_loginFault()");						for each (var fault:String in event)			{				outputLabel.text += (event[fault]);			}		}			// We've received the application URL from SWFAddress.		override protected function urlInit():void		{			// Get login status.			// TODO: Add an execute method to the base class so we don't have to 			//       call the Service.call method and pass a reference to ourselves manually.			//       i.e., execute("user.login", "http://localhost:8080/examples/initial/");			var baseUrl:String = SWFAddress.getBaseURL();			var loginReturnUrl:String = SWFAddress.getValue();						execute("user.login", baseUrl, loginReturnUrl);					}		// Execute: Makes a service call		// TODO: Pull out.		protected function execute(serviceName:String, ...args):void		{			// Add the current 			args.unshift(this);			args.unshift(serviceName);			Service.call.apply(Service.call, args);		}		// The application URL has changed.		override protected function urlChange():void		{			var deepLink:String = SWFAddress.getValue();			accessURLLabel.text = deepLink;						var selectedState:uint = 0;	// default to home			for (var i:uint = 0; i < urls.length; i++)			{				var currentUrl:Object = urls[i];				if (currentUrl.path == deepLink)				{					// If the path needs authentication, make sure user is logged in.					if ( (currentUrl.auth && Model.auth) || !currentUrl.auth)					{						selectedState = i;						break;					}				}			}									tabNav.selectedIndex = selectedState;					}			//		// UI event handlers		//				private function loginButtonClickHandler(event:Event):void		{			var url:String = (loginButton.label == "Login") ? Model.loginURL : Model.logoutURL;			getURL(url);		}				// TabBar change handler		private function tabChangeHandler(event:IndexChangedEvent):void		{			var tabNav:TabNavigator = event.target as TabNavigator;								// Of course, a more complicated app would need a more flexible solution.			// (And so I'm going to develop one in the coming days!) :)			SWFAddress.setValue( urls[tabNav.selectedIndex].path );			var baseUrl:String = SWFAddress.getBaseURL();			var loginReturnUrl:String = SWFAddress.getValue();						// Re-generate the login and logout URLs when the URL changes.			execute("user.getUrls", baseUrl, loginReturnUrl);					}	}}